

<head>
  <title>ATL Roam Temporal Map</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.min.js"></script>

  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
    }
    #map {
      height: 100vh;
      width: 100vw;
    }
    .controls {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      z-index: 1000;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      background: rgba(255,255,255,0.9);
      padding: 8px;
      border-radius: 8px;
    }
    .controls select,
    .controls button {
      font-size: 14px;
      padding: 5px;
      flex: 1 1 120px;
    }
  </style>
</head>
<body>
<div class="controls">
  <input type="text" id="vibeSearchInput" placeholder="What's the vibe..." />
  <select id="themeDropdown">
  <option value="">Select Theme</option>
  <option value="al fresco all day">Al Fresco All Day</option>
  <option value="art & culture">Art & Culture</option>
  <option value="art to afterparty">Art to Afterparty</option>
  <option value="artsy & indie">Artsy & Indie</option>
  <option value="brunch & beyond">Brunch & Beyond</option>
  <option value="cheap & cheerful">Cheap & Cheerful</option>
  <option value="chill hang">Chill Hang</option>
  <option value="creative kickstart">Creative Kickstart</option>
  <option value="date day">Date Day</option>
  <option value="date night">Date Night</option>
  <option value="foodie tour">Foodie Tour</option>
  <option value="friends night out">Friends Night Out</option>
  <option value="gallery crawl">Gallery Crawl</option>
  <option value="health nut">Health Nut</option>
  <option value="hidden gems">Hidden Gems</option>
  <option value="last call">Last Call</option>
  <option value="late start legends">Late Start Legends</option>
  <option value="luxe life">Luxe Life</option>
  <option value="midday recharge">Midday Recharge</option>
  <option value="mindful mornings">Mindful Mornings</option>
  <option value="music mile">Music Mile</option>
  <option value="neighborhood sampler">Neighborhood Sampler</option>
  <option value="nightcap circuit">Nightcap Circuit</option>
  <option value="pages to pours">Pages to Pours</option>
  <option value="party time">Party Time</option>
  <option value="patio perfection">Patio Perfection</option>
  <option value="post-work wind down">Post-Work Wind Down</option>
  <option value="quiet escape">Quiet Escape</option>
  <option value="rom-com main character">Rom-Com Main Character</option>
  <option value="rooftops & views">Rooftops & Views</option>
  <option value="saturday surge">Saturday Surge</option>
  <option value="self-care">Self-Care</option>
  <option value="solo explorer">Solo Explorer</option>
  <option value="sports day">Sports Day</option>
  <option value="street food safari">Street Food Safari</option>
  <option value="stretch, shop, sip">Stretch, Shop, Sip</option>
  <option value="sunrise start">Sunrise Start</option>
  <option value="sunset lovers">Sunset Lovers</option>
  <option value="sunday reset">Sunday Reset</option>
  <option value="tech bro escape">Tech Bro Escape</option>
  <option value="vintage vibes">Vintage Vibes</option>
  <option value="weekend warriors">Weekend Warriors</option>
  <option value="work session">Work Session</option>
  </select>
  <select id="neighborhood-input">
<option value="">Select Neighborhood</option>
<option value="alphabet city">Alphabet City</option>
<option value="bedstuy">BedStuy</option>
<option value="bushwick">Bushwick</option>
<option value="chelsea">Chelsea</option>
<option value="chinatown">Chinatown</option>
<option value="clinton hill">Clinton Hill</option>
<option value="crown heights">Crown Heights</option>
<option value="downtown brooklyn">Downtown Brooklyn</option>
<option value="dumbo">Dumbo</option>
<option value="east village">East Village</option>
<option value="fort greene">Fort Greene</option>
<option value="gowanus">Gowanus</option>
<option value="gramercy">Gramercy</option>
<option value="greenpoint">Greenpoint</option>
<option value="greenwich village">Greenwich Village</option>
<option value="long island city">Long Island City</option>
<option value="lower east side">Lower East Side</option>
<option value="midtown">Midtown</option>
<option value="red hook">Red Hook</option>
<option value="soho">SoHo</option>
<option value="tribeca">Tribeca</option>
<option value="upper east side">Upper East Side</option>
<option value="upper west side">Upper West Side</option>
<option value="west village">West Village</option>
<option value="williamsburg">Williamsburg</option>
</select>
  <select id="priceFilter">
    <option value="">Price</option>
    <option value="$">$</option>
    <option value="$$">$$</option>
    <option value="$$$">$$$</option>
    <option value="$$$$">$$$$</option>
  </select>
  <select id="durationDropdown">
    <option value="medium">How Long?</option>
    <option value="short">Short (â‰¤2h)</option>
    <option value="medium">Medium (2.5â€“5h)</option>
    <option value="long">Long (5.5â€“8h)</option>
  </select>
  <button id="crawlNowBtn">Crawl Now</button>
  <button id="saveRouteBtn">Save Route</button>
<button id="clearRouteBtn">Clear Route</button>
<button id="favoritesBtn">My Favorites</button>
<label><input type="checkbox" id="liveToggle" /> Only Show Live</label>
</div>
<div id="map"></div>
<div id="crawlSummary" style="display:none; padding: 16px; background: #fff; border: 2px solid #333; max-width: 300px; position: absolute; top: 20px; right: 20px; z-index: 9999; box-shadow: 0 0 10px rgba(0,0,0,0.2); border-radius: 8px;">
    <!-- Populated by JS -->
  </div>
  <div id="routePreview" style="
  position: fixed;
  top: 80px;
  right: 0;
  width: 250px;
  max-height: 90vh;
  overflow-y: auto;
  background: white;
  border-left: 2px solid #ccc;
  box-shadow: -2px 0 5px rgba(0,0,0,0.1);
  padding: 10px;
  display: none;
  z-index: 1000;
">
  <h4>ðŸ§­ Route Preview</h4>
  <ol id="routeList"></ol>
</div>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>
<script>
const defaultIcon = L.icon({
  iconUrl: 'https://unpkg.com/leaflet@1.9.3/dist/images/marker-icon.png',
  shadowUrl: 'https://unpkg.com/leaflet@1.9.3/dist/images/marker-shadow.png',
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});

  let allLocations = [];
  
const map = L.map('map', {
  zoomControl: false
}).setView([40.72, -73.98], 12);
  L.control.zoom({ position: 'bottomleft' }).addTo(map);
L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
  attribution: '&copy; OpenStreetMap contributors & Carto',
  subdomains: 'abcd',
  maxZoom: 19
}).addTo(map);

  const dayPartColors = {
  M: 'blue',         // Morning
  MD: 'green',       // Midday
  A: 'orange',       // Afternoon
  HH: 'gold',      // Happy Hour 
  E: 'violet',          // Evening
  L: 'red'         // Late Night 
};


  function isLocationOpenNow(ev) {
  const now = new Date();
  const dayKeys = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
  const todayKey = dayKeys[now.getDay()];
  const yesterdayKey = dayKeys[(now.getDay() + 6) % 7];
  const currentHour = now.getHours();

  const todayHours = ev.hoursNumeric?.[todayKey];
  const yesterdayHours = ev.hoursNumeric?.[yesterdayKey];

  const isWithin = (open, close) => {
    if (close < open) {
      return currentHour >= open || currentHour < close;
    } else {
      return currentHour >= open && currentHour < close;
    }
  };

  // Check if still open from yesterdayâ€™s late-night hours
  if (yesterdayHours && yesterdayHours.open !== undefined && yesterdayHours.close !== undefined) {
    if (yesterdayHours.close < yesterdayHours.open && currentHour < yesterdayHours.close) {
      return true;
    }
  }

  // Check todayâ€™s hours
  if (todayHours && todayHours.open !== undefined && todayHours.close !== undefined) {
    return isWithin(todayHours.open, todayHours.close);
  }

  return false;
}
  
  let globalEvents = [];
let allMarkers = [];
let selectedRoute = [];
let currentRoute = null;
const maxRouteStops = 5;
  let savedRoutes = [];
  let eventsToday = [];

// â”€â”€â”€ DRAW ROUTE FUNCTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawRoute() {
console.log("Redrawing route for stops:", selectedRoute);
  
  if (currentRoute) {
    map.removeControl(currentRoute);
    currentRoute = null;
  }
  if (selectedRoute.length < 2) return;

  const waypoints = selectedRoute.map(loc => L.latLng(loc.lat, loc.lon));
  currentRoute = L.Routing.control({
    waypoints,
    routeWhileDragging: false,
    draggableWaypoints: false,
    addWaypoints: false,
    show: false,
    createMarker: () => null, // Hide default markers
    lineOptions: {
      styles: [{ color: 'red', opacity: 0.9, weight: 5 }]
    },
  }).addTo(map);
}

  // â”€â”€â”€ ROUTE PREVIEW FUNCTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function updateRoutePreview() {
  const container = document.getElementById('routePreview');
  const list = document.getElementById('routeList');

  if (selectedRoute.length === 0) {
    container.style.display = 'none';
    list.innerHTML = '';
    return;
  }

  container.style.display = 'block';
  list.innerHTML = '';

  selectedRoute.forEach((stop, idx) => {
    const item = document.createElement('li');
    item.textContent = stop.name;

    const removeBtn = document.createElement('button');
    removeBtn.textContent = 'âŒ';
    removeBtn.style.marginLeft = '10px';
    removeBtn.onclick = () => {
      selectedRoute.splice(idx, 1);
      drawRoute();
      updateRoutePreview();
    };

    item.appendChild(removeBtn);
    list.appendChild(item);
  });
}

// â”€â”€â”€ ADD TO ROUTE HANDLER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function addToRoute(ev) {
  console.log("addToRoute invoked", ev.name, selectedRoute.length);

  if (selectedRoute.length >= maxRouteStops) {
    alert(`You can add up to ${maxRouteStops} stops only.`);
    return;
  }

  if (selectedRoute.some(loc => loc.name === ev.name)) {
    alert('This location is already in your route.');
    return;
  }

  selectedRoute.push(ev);
  console.log("âœ… Location added to route:", ev.name);
  console.log("ðŸ§­ Route now has:", selectedRoute.map(s => s.name));

  drawRoute();

  if (selectedRoute.length >= 2) {
    setTimeout(showRouteControls, 100); // ensures DOM is ready
  }

  updateRoutePreview(); // this shows the list of stops on the right side
}

// â”€â”€â”€ FILTER MARKERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function filterMarkersByVibe() {
  const vibeSearch = document.getElementById('vibeSearchInput').value.trim().toLowerCase();
  const onlyLive = document.getElementById('liveToggle').checked;
  const baseEvents = onlyLive ? eventsToday : globalEvents;

  const filtered = baseEvents.filter(ev => {
    if (!vibeSearch) return true;

    const nameMatch = (ev.name || '').toLowerCase().includes(vibeSearch);
    const vibeMatch = (ev.vibe || '').toLowerCase().includes(vibeSearch);

    return nameMatch || vibeMatch;
  });

  renderMarkers(filtered);
}

// â”€â”€â”€ RENDER MARKERS (with Similar & Add-To-Route) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const markerLayer = L.layerGroup().addTo(map);
// ðŸ”¹ Global cache for all markers (used by the route filter)
window.allMarkers = window.allMarkers || [];

function showRouteControls() {
  const popup = document.querySelector('.leaflet-popup-content');
  console.log("Popup element:", popup);
  console.log("showRouteControls: popup content found?", !!popup);

  if (!popup) return;

  const existingSaveBtn = popup.querySelector('.save-route-btn');
  const existingExportBtn = popup.querySelector('.export-route-btn');
  if (existingSaveBtn) existingSaveBtn.remove();
  if (existingExportBtn) existingExportBtn.remove();

  if (selectedRoute.length >= 2) {
    const saveBtn = document.createElement("button");
    saveBtn.textContent = "ðŸ’¾ Save to My Favorites";
    saveBtn.className = "save-route-btn";
    saveBtn.onclick = () => {
      const existing = localStorage.getItem('savedRoutes');
      const routes = existing ? JSON.parse(existing) : [];
      routes.push([...selectedRoute]);
      localStorage.setItem('savedRoutes', JSON.stringify(routes));
      alert("Crawl saved to favorites!");
    };
    popup.appendChild(saveBtn);

    const exportBtn = document.createElement("button");
    exportBtn.textContent = "Export to Google Maps";
    exportBtn.className = "export-route-btn";
    exportBtn.onclick = () => {
      const base = "https://www.google.com/maps/dir/";
      const waypoints = selectedRoute.map(stop => `${stop.lat},${stop.lon}`).join('/');
      const url = `${base}${waypoints}`;
      window.open(url, "_blank");
    };
    popup.appendChild(exportBtn);
  }
}

function renderMarkers(events, crawlMode = false) {
  markerLayer.clearLayers();
  // ðŸ”¹ Reset and rebuild the global marker cache each render
  window.allMarkers = [];

  const weekdayKeys = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
  const todayIndex = new Date().getDay();

  events.forEach(ev => {
    const rawPart = ev.dayParts?.[weekdayKeys[todayIndex]];
    const isOpen = isLocationOpenNow(ev);
    const markerColor = isOpen && rawPart && rawPart !== '-'
      ? (dayPartColors[rawPart] || 'grey')
      : 'grey';

    const icon = new L.Icon({
      iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-${markerColor}.png`,
      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });

    // ðŸ”¹ Tag each marker with a stable venueId (used for route filtering)
    const venueId = ev.id || ev.name;
    const marker = L.marker([parseFloat(ev.lat), parseFloat(ev.lon)], { icon, venueId });
    marker.ev = ev;

    marker.bindPopup(`<strong>${ev.name}</strong><br>${(ev.vibe || '').split(',').map(v => v.trim()).join(', ')}`);
    marker.on('click', () => {
      map.setView(marker.getLatLng(), 16);
      marker.openPopup();
    });

    if (!crawlMode && eventsToday.includes(ev)) {
      marker.bindTooltip("ðŸ”´ Live Today!", { permanent: true }).addTo(map);
    }

    // ðŸ”¹ Keep an authoritative list of all markers
    window.allMarkers.push(marker);
  });

  window.allMarkers.forEach(marker => {
    const ev = marker.ev;
    const latlng = marker.getLatLng();
    const isOpen = isLocationOpenNow(ev);

    if (crawlMode) {
      // In crawl mode, just add the markers you passed in
      marker.addTo(markerLayer);
      return;
    }

    const thisVibes = (ev.vibe || '')
      .split(',')
      .map(v => v.trim().toLowerCase())
      .filter(Boolean);

    const similar = window.allMarkers
      .filter(m => m !== marker && latlng.distanceTo(m.getLatLng()) <= 350)
      .filter(m => {
        const otherVibes = (m.ev.vibe || '')
          .split(',')
          .map(v => v.trim().toLowerCase())
          .filter(Boolean);
        return thisVibes.some(v => otherVibes.includes(v));
      })
      .slice(0, 3);

    const similarList = similar.length
      ? '<ul>' + similar.map(m => `<li>${m.ev.name}</li>`).join('') + '</ul>'
      : '<em>No similar places nearby.</em>';

    const popupContent = `
      <div style="font-size:14px;line-height:1.4;">
        <strong>${ev.name}</strong><br/>
        <em>Vibe:</em> ${ev.vibe}<br/>
        <em>Hours:</em> ${ev.hours?.[todayIndex] || 'N/A'}<br/>
        <em>Status:</em> ${isOpen ? '<span style="color:green;">Open Now</span>' : '<span style="color:red;">Closed</span>'}<br/>
        <a href="${ev.link}" target="_blank">More Info</a>
        <hr/>
        <strong>Could also be the move..:</strong>
        ${similarList}
        <br/><br/>
        <button class="add-route-btn">Add to Route</button>
      </div>
    `;

    marker.bindPopup(popupContent).addTo(markerLayer);

    marker.on('popupopen', () => {
      setTimeout(() => {
        const popup = marker._popup.getElement();
        const btn = popup.querySelector('.add-route-btn');
        if (btn) {
          console.log("âœ… Add to Route button found for:", ev.name);
          btn.onclick = () => {
            console.log("ðŸŸ¢ Add to Route clicked for:", ev.name);
            addToRoute(ev);
          };
        } else {
          console.warn("âŒ Add to Route button not found in popup");
        }
      }, 50); // Slight delay ensures DOM is ready
    });
  });

  // â”€â”€â”€ ðŸ”’ Keep shared views filtered post-render (if ?route= is present) â”€â”€â”€
  try {
    const params = new URLSearchParams(location.search);
    const q = params.get('route');
    if (q) {
      const ids = q.split(',').map(s => s.trim()).filter(Boolean);
      showOnlyRouteMarkers(map, window.allMarkers || [], ids);
    }
  } catch (e) {
    console.warn('Post-render route filter failed:', e);
  }

  // â”€â”€â”€ ðŸ”” Signal once that markers are fully rendered â”€â”€â”€
  window.dispatchEvent(new CustomEvent('markers:rendered'));
}

  // --- Bootstrap: apply route from URL after markers exist ---
function getRouteIdsFromURL() {
  try {
    const params = new URLSearchParams(location.search);
    const q = params.get('route');
    return q ? q.split(',').map(s => s.trim()).filter(Boolean) : [];
  } catch { return []; }
}

document.addEventListener('DOMContentLoaded', () => {
  const routeIds = getRouteIdsFromURL();
  if (!routeIds.length) return;

  // Apply immediately if markers already exist...
  const tryApply = () => {
    if ((window.allMarkers || []).length) {
      applyRouteFromURL();                 // your existing function (now sets selectedRoute + enables clear)
      window.removeEventListener('markers:rendered', tryApply);
    }
  };

  // ...otherwise wait for renderMarkers to finish
  window.addEventListener('markers:rendered', tryApply);
  tryApply();
});


  function applyRouteFromURL(){
  const params = new URLSearchParams(location.search);
  const route = params.get('route');
  if (!route) return;

  const routeIds = route.split(',').map(s => s.trim()).filter(Boolean);

  // Hide non-route markers immediately
  showOnlyRouteMarkers(map, window.allMarkers || [], routeIds);

  // Rebuild waypoints / route line if desired
  const byId = new Map(globalEvents.map(ev => [ev.id || ev.name, ev]));
  const matchedEvents = routeIds.map(id => byId.get(id)).filter(Boolean);

  // Keep selectedRoute in sync
  window.selectedRoute = matchedEvents;

  const waypoints = matchedEvents.map(loc => 
    L.latLng(parseFloat(loc.lat), parseFloat(loc.lon))
  );

  if (window.routeLayer) map.removeControl(window.routeLayer);
  if (waypoints.length >= 2) {
    window.routeLayer = L.Routing.control({
      waypoints,
      routeWhileDragging: false,
      draggableWaypoints: false,
      addWaypoints: false,
      show: false
    }).addTo(map);
  }

  // âœ… Enable Clear Route button since a route is now active
  if (typeof setClearRouteButtonEnabled === 'function') {
    setClearRouteButtonEnabled(true);
  }
}


// ðŸ”¹ Route filtering helpers (keep only markers that are part of the route)
function showOnlyRouteMarkers(map, markers, routeIds) {
  const routeSet = new Set(routeIds);
  markerLayer.clearLayers(); // ðŸ”‘ reset the group to avoid ghosts

  (markers || []).forEach(m => {
    const onRoute = routeSet.has(m.options && m.options.venueId);
    if (onRoute) {
      markerLayer.addLayer(m); // ðŸ”‘ add back into the same group
    }
  });
}

// ðŸ”¹ Convenience: call this right after you set selectedRoute in generateCrawlRoute()
function filterMapToRoute() {
  try {
    const routeIds = (selectedRoute || []).map(l => l.id || l.name);
    showOnlyRouteMarkers(map, window.allMarkers || [], routeIds);
  } catch (e) {
    console.warn('Marker filtering failed:', e);
  }
}

  // --- Ensure expected globals exist ---
window.allMarkers   = window.allMarkers   || [];   // filled by renderMarkers()
window.routeLayer   = window.routeLayer   || null; // L.Routing.control instance
window.routeGroup   = window.routeGroup   || null; // optional LayerGroup for route-only pins
window.selectedRoute= window.selectedRoute|| [];   // your in-memory route array

// Bring all markers back into the visible layer group
function restoreAllMarkers(map, markers) {
  if (!window.markerLayer) {
    console.warn('markerLayer not found; creating a new one');
    window.markerLayer = L.layerGroup().addTo(map);
  }
  markerLayer.clearLayers();
  (markers || []).forEach(m => markerLayer.addLayer(m));
}

// Full clear: remove route line/control, restore markers, reset state + URL
// --- bring all markers back into the visible layer group (NEW) ---
function restoreAllMarkers(map, markers) {
  if (!window.markerLayer) {
    console.warn('markerLayer not found; creating a new one');
    window.markerLayer = L.layerGroup().addTo(map);
  }
  markerLayer.clearLayers();
  (markers || []).forEach(m => markerLayer.addLayer(m));
}

function clearRoute(){
  // 1) Remove the route line / control
  if (window.routeLayer) {
    try { map.removeControl(window.routeLayer); } catch(_) {}
    window.routeLayer = null;
  }

  // 2) Restore ALL markers to the map (via markerLayer)
  restoreAllMarkers(map, window.allMarkers || []);

  // 3) If you used a dedicated route-only group, clear it
  if (window.routeGroup) { try { window.routeGroup.clearLayers(); } catch(_) {} }

  // 4) Reset in-memory route state
  window.selectedRoute = [];

  // 5) Strip ?route= from the URL so reloads don't re-filter the map
  try {
    const url = new URL(location.href);
    if (url.searchParams.has('route')) {
      url.searchParams.delete('route');
      history.replaceState(null, '', url.toString());
    }
  } catch (e) {
    console.warn('URL cleanup failed:', e);
  }

  // 6) (Optional) clear any UI summary
  if (typeof showCrawlSummary === 'function') {
    try { showCrawlSummary([]); } catch(_) {}
  }

  // 7) (Optional) disable the clear button until a new route is built
  setClearRouteButtonEnabled(false);

  console.log('ðŸ§¹ Route cleared and markers restored');
}

// Utility: enable/disable the Clear Route button for good UX
function setClearRouteButtonEnabled(enabled) {
  const btn = document.getElementById('clearRouteBtn');
  if (!btn) return;
  btn.disabled = !enabled;
  btn.style.opacity = enabled ? '1' : '0.6';
  btn.style.cursor  = enabled ? 'pointer' : 'not-allowed';
}

// Wire the Clear Route button (robust to DOM timing) (UPDATED)
(function wireClearRouteButton(){
  const hook = () => {
    const btn = document.getElementById('clearRouteBtn');
    if (!btn) { console.warn('#clearRouteBtn not found in DOM'); return; }
    btn.addEventListener('click', clearRoute);
    // Start disabled until a route exists
    setClearRouteButtonEnabled(!!(window.selectedRoute && window.selectedRoute.length));
  };
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', hook);
  } else {
    hook();
  }
})();

// Call this AFTER you generate a route to enable the button automatically.
// Example: after `selectedRoute = [...crawlRoute]; showCrawlSummary(crawlRoute);`
function onRouteGenerated() {
  setClearRouteButtonEnabled(true);
}


  
fetch('events.json')
  .then(res => res.json())
  .then(events => {
    globalEvents = events;

    const todayStr = new Date().toISOString().slice(0, 10);
    eventsToday = globalEvents.filter(ev =>
      ev.dateEvents?.some(e => e.date === todayStr)
    );

    console.log("ðŸ“… Events Today:", eventsToday);

   const urlParams = new URLSearchParams(window.location.search);
if (urlParams.has('crawl')) {
  try {
    const crawl = JSON.parse(decodeURIComponent(urlParams.get('crawl')));
    console.log("ðŸ”— Loaded crawl from URL:", crawl);

    renderMarkers(crawl, true); // âœ… pass crawlMode = true
    selectedRoute = [...crawl];
    drawRoute();
    showCrawlSummary(crawl);

    document.querySelector('.controls').style.display = 'none'; // âœ… Hide controls for clean viewer

    return; // â›” Skip default render if crawl loaded
  } catch (e) {
    console.error("Invalid crawl link:", e);
  }
}

    // fallback to default view
    renderMarkers(events);
  })
  .catch(err => {
    console.error('Error loading events:', err);
    alert('Failed to load locations.');
  });


const savedFromStorage = localStorage.getItem('savedRoutes');
if (savedFromStorage) {
  savedRoutes = JSON.parse(savedFromStorage);
}
  
document.getElementById('saveRouteBtn').addEventListener('click', () => {
  console.log('ðŸ§­ selectedRoute at time of save:', selectedRoute); // âœ… moved inside event

  if (selectedRoute.length < 2) {
    alert('Add at least 2 locations to save a route.');
    return;
  }

  savedRoutes.push([...selectedRoute]);
  localStorage.setItem('savedRoutes', JSON.stringify(savedRoutes)); // âœ… persist to localStorage
  console.log('ðŸ” Saved to localStorage:', savedRoutes);
  alert('Route saved to favorites.');
});

document.getElementById('favoritesBtn').addEventListener('click', () => {
  openFavoritesModal();
});

document.getElementById('favoritesBtn').addEventListener('click', () => {
  openFavoritesModal();
});

  document.getElementById('vibeSearchInput').addEventListener('input', () => {
  if (globalEvents.length > 0) {
    filterMarkersByVibe();
  }
});
  
const neighborhoodCenters = {
  "alphabet city": L.latLng(40.7265, -73.9815),
  "bedstuy": L.latLng(40.6850, -73.9419),
  "bushwick": L.latLng(40.6943, -73.9213),
  "chelsea": L.latLng(40.7465, -74.0014),
  "chinatown": L.latLng(40.7158, -73.9970),
  "clinton hill": L.latLng(40.6896, -73.9606),
  "crown heights": L.latLng(40.6681, -73.9448),
  "downtown brooklyn": L.latLng(40.6928, -73.9903),
  "dumbo": L.latLng(40.7033, -73.9881),
  "east village": L.latLng(40.7260, -73.9816),
  "fort greene": L.latLng(40.6870, -73.9750),
  "gowanus": L.latLng(40.6753, -73.9911),
  "gramercy": L.latLng(40.7376, -73.9857),
  "greenpoint": L.latLng(40.7301, -73.9546),
  "greenwich village": L.latLng(40.7336, -74.0027),
  "lower east side": L.latLng(40.7150, -73.9843),
  "long island city": L.latLng(40.7440, -73.9488),
  "midtown": L.latLng(40.7549, -73.9840),
  "red hook": L.latLng(40.6770, -74.0110),
  "soho": L.latLng(40.7233, -74.0030),
  "tribeca": L.latLng(40.7163, -74.0086),
  "upper east side": L.latLng(40.7736, -73.9566),
  "upper west side": L.latLng(40.7870, -73.9754),
  "west village": L.latLng(40.7359, -74.0036),
  "williamsburg": L.latLng(40.7081, -73.9571)
};

  const crawlFlows = {
  "al fresco all day": ["brunch", "garden", "patio", "cocktail", "dinner"],
  "art & culture": ["gallery", "museum", "cocktail", "music", "dessert"],
  "art to afterparty": ["gallery", "exhibit", "wine bar", "dinner", "club"],
  "artsy & indie": ["gallery", "random gem", "bookstore", "wine bar", "dinner", "music"],
  "brunch & beyond": ["brunch", "market", "rooftop", "bar", "dessert"],
  "cheap & cheerful": ["coffee", "market", "random gem", "gallery", "dinner", "bar"],
  "chill hang": ["coffee", "bookstore", "random gem", "lifestyle", "bar", "dessert"],
  "creative kickstart": ["coffee", "gallery", "random gem", "bookstore", "lunch"],
  "date day": ["brunch", "park", "random gem", "lifestyle", "dinner", "dessert"],
  "date night": ["dinner", "music", "speakeasy", "dessert"],
  "foodie tour": ["market", "lunch", "cocktail", "dinner", "dessert"],
  "friends night out": ["bar", "bar", "dinner", "club", "late-night"],
  "gallery crawl": ["gallery", "gallery", "lunch", "wine bar", "music"],
  "health nut": ["fitness", "juice bar", "spa", "garden"],
  "hidden gems": ["random gem", "cafe", "restaurant", "speakeasy", "bar"],
  "last call": ["bar", "club", "late-night", "speakeasy", "lounge", "after hours"],
  "late start legends": ["brunch", "bar", "cocktail", "dinner", "speakeasy", "lounge"],
  "luxe life": ["gallery", "dinner", "cocktail", "lounge"],
  "midday recharge": ["coffee", "lunch", "park", "gallery"],
  "mindful mornings": ["wellness", "coffee", "garden", "market", "spa"],
  "music mile": ["live music", "bar", "dinner", "cocktail", "club"],
  "neighborhood sampler": ["coffee", "random gem", "lunch", "gallery", "bar"],
  "nightcap circuit": ["cocktail", "speakeasy", "lounge", "dessert"],
  "pages to pours": ["bookstore", "coffee", "gallery", "wine bar", "lounge"],
  "party time": ["bar", "dinner", "bar", "club", "late-night"],
  "patio perfection": ["brunch", "rooftop", "cocktail", "dinner", "dessert"],
  "post-work wind down": ["bar", "dinner", "cocktail", "lounge"],
  "quiet escape": ["bookstore", "tea", "park", "random gem", "lounge"],
  "rom-com main character": ["coffee", "gallery", "wine bar", "rooftop", "speakeasy"],
  "rooftops & views": ["rooftop", "cocktail", "dinner", "lounge"],
  "saturday surge": ["activity", "bar", "dinner", "bar", "club", "late-night"],
  "self-care": ["fitness", "spa", "tea", "bookstore", "park"],
  "solo explorer": ["coffee", "random gem", "bookstore", "market", "park", "rooftop"],
  "sports day": ["fitness", "activity", "lunch", "bar", "dinner"],
  "street food safari": ["market", "street food", "cocktail", "dessert"],
  "stretch, shop, sip": ["yoga", "lifestyle", "juice bar", "brunch", "dessert"],
  "sunrise start": ["fitness", "bakery", "coffee", "market", "park"],
  "sunset lovers": ["park", "rooftop", "dinner", "cocktail"],
  "sunday reset": ["fitness", "market", "lifestyle", "tea", "dinner"],
  "tech bro escape": ["cocktail", "rooftop", "dinner", "club", "late-night"],
  "vintage vibes": ["thrift store", "coffee", "random gem", "cocktail"],
  "weekend warriors": ["bar", "speakeasy", "bar", "club", "late-night"],
  "work session": ["coffee", "lunch", "coffee", "cocktail"]
};

  
  const themeMap = {
  "art & culture": ["gallery", "aesthetic", "museum", "art", "exhibit", "creative", "theater", "film", "architecture", "history", "design", "photography"],
  "artsy & indie": ["gallery", "vinyl", "underground", "zine", "eclectic", "alt", "poetry", "studio", "indie", "niche", "handmade", "crafts", "bohemian"],
  "brunch & beyond": ["brunch", "mimosa", "day party", "pancakes", "bistro", "patio", "sunny", "casual", "daytime", "weekend", "outdoor", "social"],
  "cheap & cheerful": ["diner", "cheap", "budget", "street", "casual", "$", "bite", "fast", "local", "market", "takeout", "food truck"],
  "chill hang": ["lounge", "cozy", "relaxed", "intimate", "chill", "sofa", "vintage", "casual", "warm", "neighborhood", "laid-back", "friendly"],
  "creative kickstart": ["studio", "journal", "sketch", "gallery", "quiet", "inspiration", "cafÃ©", "bookstore", "sunny", "vinyl", "art", "notebook", "design", "creative space", "makers"],
  "date day": ["brunch", "park", "casual", "romantic", "patio", "stroll", "serendipity", "daytime", "garden", "outdoor", "cafÃ©", "dessert"],
  "date night": ["romantic", "cocktail", "jazz", "twilight", "vibe", "wine", "dim", "moody", "candlelit", "intimate", "charming", "slow-paced"],
  "foodie tour": ["restaurant", "tasting", "chef", "bistro", "eats", "gastro", "brunch", "dining", "flavors", "street food", "multi-course", "local cuisine"],
  "friends night out": ["loud", "crowded", "bar", "dinner", "club", "dj", "party", "scene", "drinks", "late-night", "social", "vibrant"],
  "gallery crawl": ["gallery", "exhibit", "art", "creative", "museum", "opening", "culture", "fine art", "contemporary", "showcase", "art walk"],
  "health nut": ["wellness", "juice", "smoothie", "matcha", "organic", "spa", "bathhouse", "vegan", "yoga", "fitness", "light bite", "gym", "meditation", "fresh"],
  "hidden gems": ["speakeasy", "secret", "underground", "niche", "alt", "unmarked", "local", "offbeat", "exclusive", "rare", "quirky", "low-profile"],
  "last call": ["late-night", "karaoke", "after hours", "lively", "spontaneous", "gritty", "unfiltered", "nocturnal", "dance", "dark", "shots", "underground", "loose", "unhinged", "boozy", "nightcap"],
  "late start legends": ["brunch", "cocktails", "twilight", "pre-game", "vibe", "evening", "casual", "low key", "date", "nightlife", "urban", "chill"],
  "luxe life": ["fine dining", "aesthetic", "exclusive", "high-end", "rooftop", "wine", "luxury", "private", "VIP", "premium", "gourmet", "opulent", "exclusive view"],
  "midday recharge": ["lunch", "coffee", "cafÃ©", "juice", "quick bite", "park", "sunlight", "relaxed", "low key", "grab-and-go", "outdoor", "break"],
  "mindful mornings": ["yoga", "meditation", "spa", "sunlight", "tea", "calm", "minimal", "introspective", "garden", "journal", "wellness", "fresh air", "stretch"],
  "neighborhood sampler": ["walkable", "local", "market", "coffee", "casual", "random gem", "community vibe", "shops", "restaurants", "street life", "hidden spot", "corner cafÃ©"],
  "nightcap circuit": ["speakeasy", "whiskey", "jazz", "cozy", "lounge", "low light", "late", "neat", "intimate", "bar", "cigar", "smooth"],
  "party time": ["club", "dance", "beats", "late", "dj", "loud", "drinks", "bar", "crowded", "energy", "flashy", "after hours"],
  "post-work wind down": ["happy hour", "bar", "tapas", "light bite", "craft beer", "after work", "relax", "casual", "patio", "drinks", "evening", "mingle"],
  "quiet escape": ["tea", "bookstore", "park", "quiet", "introspective", "relaxed", "cozy", "minimal", "serene", "slow", "niche", "retreat"],
  "rom-com main character": ["twilight", "charming", "patio", "vintage", "wine", "candlelit", "walkable", "cozy", "date", "serendipity", "scenic", "whimsical"],
  "rooftops & views": ["rooftop", "view", "skyline", "sunset", "elevated", "balcony", "overlook", "outdoor", "cocktail", "scenic", "glamorous", "night lights"],
  "saturday surge": ["dance", "dj", "crowded", "club", "party", "high energy", "beats", "rooftop", "late", "scene", "vibrant", "after hours"],
  "self-care": ["spa", "relax", "yoga", "meditation", "serenity", "retreat", "tea", "calm", "detox", "massage", "rejuvenate", "peace"],
  "solo explorer": ["bookstore", "quiet", "scenic", "cafÃ©", "park", "rooftop", "garden", "introspective", "nook", "wander", "hidden spot", "photo walk"],
  "sports day": ["active", "game", "match", "fitness", "team", "outdoor", "energy", "training", "stadium", "competition", "field", "spectator"],
  "street food safari": ["market", "street", "casual", "cheap", "local", "spicy", "crowd", "quick bite", "vendor", "takeout", "night market", "pop-up"],
  "sunrise start": ["coffee", "matcha", "sunrise", "morning", "cafÃ©", "bakery", "brunch", "acai", "patio", "quiet", "fresh", "early"],
  "sunset lovers": ["park", "view", "golden hour", "romantic", "cocktail", "outdoor", "patio", "date", "skyline", "twilight", "serene", "photogenic"],
  "sunday reset": ["garden", "tea", "spa", "quiet", "book", "relax", "wellness", "reflection", "meditation", "sunlight", "fresh", "slow"],
  "tech bro escape": ["steakhouse", "cocktail", "crypto", "rooftop", "sleek", "bourbon", "high-end", "modern", "rare", "network", "exclusive", "private"],
  "vintage vibes": ["thrift", "retro", "vintage", "coffee", "vinyl", "nostalgic", "eclectic", "antique", "boho", "quirky", "retro bar", "record shop"],
  "weekend warriors": ["dive bar", "after hours", "shots", "karaoke", "late night", "chaotic", "party", "crowd", "open late", "wild", "rowdy", "social"],
  "work session": ["cafe", "wifi", "coffee", "focus", "quiet", "workspace", "daytime", "study", "productive", "neighborhood", "light music", "comfortable seating"],
   "patio perfection": ["patio", "al fresco", "open-air", "sunny", "shade", "breezy", "terrace", "brunchy", "plants", "outdoor", "chill", "garden", "social", "view", "loungy", "relaxed"],
  "art to afterparty": ["gallery", "creative", "art", "edgy", "expressive", "cocktail", "night", "music", "mood", "chic", "theater", "neon", "bold", "late", "styled", "scene"],
  "pages to pours": ["bookstore", "quiet", "cozy", "literary", "analog", "warm", "vintage", "library", "indie", "wine", "reflective", "moody", "ink", "writerly", "poetic", "sips"],
  "al fresco all day": ["sunny", "bloom", "green", "garden", "light", "fresh", "outdoor", "easy", "brunch", "picnic", "open-air", "dog-friendly", "mellow", "daytime", "leisure", "floral", "relaxing"],
  "music mile": ["live", "sound", "vinyl", "stage", "dance", "band", "DJ", "retro", "acoustic", "loud", "rhythm", "bass", "eclectic", "energy", "jam", "neon", "beat"],
  "stretch, shop, sip": ["yoga", "fit", "lifestyle", "luxe", "local", "boutique", "intentional", "wellness", "fresh", "feminine", "spa", "curated", "flow", "soft", "leisure", "balance"]
};


function matchesTheme(loc, theme) {
  const keywords = themeMap[theme] || [];
  const allTags = [
    ...(loc.vibe || []),
    ...(typeof loc.tags === 'string' ? loc.tags.split(',').map(t => t.trim().toLowerCase()) : [])
  ];
  return keywords.some(kw => allTags.includes(kw));
}

function getCurrentDayPart() {
  const hour = new Date().getHours();
  if (hour >= 6 && hour < 11) return ['M'];
  if (hour >= 11 && hour < 14) return ['MD'];
  if (hour >= 14 && hour < 16) return ['A'];
  if (hour >= 16 && hour < 19) return ['HH'];
  if (hour >= 19 && hour < 22) return ['E'];
  return ['L']; // Late night or overnight
}

 // day key from Date object
function _dayKey(d) {
  return ["sun","mon","tue","wed","thu","fri","sat"][d.getDay()];
}

// normalize to array of {open, close} objects
function _ranges(x) {
  if (!x) return [];
  return Array.isArray(x) ? x : [x];
}

// Get actual open/close Date objects for a given date
function _intervalsForDate(d, hours) {
  const y = d.getFullYear(), m = d.getMonth(), day = d.getDate();
  const zero = new Date(y, m, day);
  zero.setHours(0, 0, 0, 0);

  const at = h => new Date(zero.getTime() + h * 3600 * 1000);

  const out = [];
  // today's ranges
  (_ranges(hours[_dayKey(d)])).forEach(r => {
    out.push([at(r.open), at(r.close)]);
  });

  // yesterday's late ranges (>24h close)
  const yst = new Date(zero);
  yst.setDate(zero.getDate() - 1);
  (_ranges(hours[_dayKey(yst)])).forEach(r => {
    if (r.close > 24) {
      const yZero = new Date(yst);
      yZero.setHours(0, 0, 0, 0);
      out.push([
        new Date(yZero.getTime() + r.open * 3600 * 1000),
        new Date(yZero.getTime() + r.close * 3600 * 1000)
      ]);
    }
  });

  return out;
}

// Check if a location is open at a given datetime
function isOpenAt(loc, when) {
  const hours = loc.hoursNumeric || {};
  return _intervalsForDate(when, hours).some(([o, c]) => when >= o && when < c);
}

  function showCrawlSummary(crawlRoute) {
  const summaryDiv = document.getElementById("crawlSummary");
  summaryDiv.innerHTML = ""; // Clear old content

  const list = document.createElement("ol");
  crawlRoute.forEach((stop, index) => {
    const item = document.createElement("li");
    const link = document.createElement("a");
    link.href = stop.link || "#";
    link.textContent = `Stop ${index + 1}: ${stop.name}`;
    link.target = "_blank";
    item.appendChild(link);
    list.appendChild(item);
  });

  summaryDiv.appendChild(list);

  const saveBtn = document.createElement("button");
  saveBtn.textContent = "ðŸ’¾ Save to My Favorites";
  saveBtn.onclick = () => {
    if (crawlRoute.length < 2) {
      alert('Add at least 2 stops to save a route.');
      return;
    }
    const existing = localStorage.getItem('savedRoutes');
    const routes = existing ? JSON.parse(existing) : [];
    routes.push([...crawlRoute]);
    localStorage.setItem('savedRoutes', JSON.stringify(routes));
    alert("Crawl saved to favorites (local only for now)!");
  };
  summaryDiv.appendChild(saveBtn);

  const exportBtn = document.createElement("button");
  exportBtn.textContent = "Export to Google Maps";
  exportBtn.onclick = () => {
    const base = "https://www.google.com/maps/dir/";
    const waypoints = crawlRoute.map(stop => `${stop.lat},${stop.lng}`).join('/');
    const url = `${base}${waypoints}`;
    window.open(url, "_blank");
  };
  summaryDiv.appendChild(exportBtn);

  function copyShareableRouteLink(crawlRoute){
  const ids = (crawlRoute || []).map(l => l.id || l.name).join(',');
  const url = new URL(location.href);
  url.searchParams.set('route', ids);   // short & robust
  navigator.clipboard.writeText(url.toString()).then(() => {
    alert('Route link copied!');
  }).catch(err => console.warn('Copy failed:', err));
}

// Replace your existing shareBtn.onclick with this:
const shareBtn = document.createElement("button");
shareBtn.textContent = "Copy Crawl Link";
shareBtn.onclick = () => {
  copyShareableRouteLink(selectedRoute || []);
};
  summaryDiv.appendChild(shareBtn);

  const closeBtn = document.createElement("button");
  closeBtn.textContent = "Close";
  closeBtn.onclick = () => {
    summaryDiv.style.display = "none";
  };
  summaryDiv.appendChild(closeBtn);

  summaryDiv.style.display = "block"; // Show it
}
  
function generateCrawlRoute() {
  const todayStr = new Date().toISOString().slice(0, 10);
  if (!globalEvents.length) {
    alert("Locations not loaded yet. Please wait a moment.");
    return;
  }

  let center;
  console.log('ðŸš¨ generateCrawlRoute() triggered');

  // Crawl timing
const crawlStart = new Date();      // or read from a UI input if you expose one
const bufferHours = 1;              // your D+1 rule (â€œ+1â€ hour buffer between stops)


  const neighborhood = document.getElementById('neighborhood-input').value.toLowerCase();
  const priceFilter = document.getElementById('priceFilter').value.trim();
  const durationSetting = document.getElementById('durationDropdown').value;
  const neighborhoodCenter = neighborhoodCenters[neighborhood];

  console.log('ðŸ“ Selected Neighborhood:', neighborhood);
  console.log('ðŸ§­ Matched Center:', neighborhoodCenters[neighborhood]);

  if (!neighborhoodCenter || isNaN(neighborhoodCenter.lat) || isNaN(neighborhoodCenter.lng)) {
    alert("Invalid or missing neighborhood center.");
    return;
  }

  center = L.latLng(neighborhoodCenter.lat, neighborhoodCenter.lng);
  const maxDuration = durationSetting === 'short' ? 2 : durationSetting === 'medium' ? 5 : 8;
  const rawTheme = document.getElementById('themeDropdown').value;
  const theme = rawTheme.trim().toLowerCase();
  const themeKeywords = (themeMap[theme] || []).map(kw => kw.toLowerCase());

  console.log('ðŸ§  Raw Theme:', rawTheme);
  console.log('ðŸŽ¯ Processed Theme:', theme);

  const priceTiers = ['$', '$$', '$$$', '$$$$'];
  const selectedTierIndex = priceTiers.indexOf(priceFilter);
  const baseDayParts = getCurrentDayPart();
  const themeOverrides = {
    "sunrise start": ["M"],
    "mindful mornings": ["M", "MD"],
    "creative kickstart": ["M", "MD"],
    "midday recharge": ["MD", "A"],
    "health nut": ["M", "MD", "A"],
    "work session": ["M", "MD", "A"],
    "brunch & beyond": ["MD", "A"],
    "late start legends": ["MD", "A", "HH"],
    "post-work wind down": ["HH", "E"],
    "golden hour": ["HH"],
    "foodie tour": ["A", "HH", "E"],
    "chill hang": ["A", "HH", "E"],
    "cheap & cheerful": ["A", "HH", "E"],
    "date night": ["E"],
    "rom-com main character": ["E"],
    "nightcap circuit": ["E", "L"],
    "party time": ["E", "L"],
    "saturday surge": ["E", "L"],
    "weekend warriors": ["L"],
    "tech bro escape": ["E", "L"],
    "self-care": ["M", "MD", "A"],
    "art & culture": ["MD", "A", "E"],
    "artsy & indie": ["A", "E"],
    "solo explorer": ["M", "MD", "A"],
    "rooftops & views": ["HH", "E"],
    "hidden gems": ["E", "L"],
    "sunday reset": ["M", "MD", "A"]
  };
  const currentDayParts = themeOverrides[theme] || baseDayParts;

  const allLocations = globalEvents.map(ev => ({
    ...ev,
    lat: parseFloat(ev.lat),
    lng: parseFloat(ev.lon),
    vibe: (ev.vibe || '').split(',').map(v => v.trim().toLowerCase()),
    tags: (ev.tags || '').split(',').map(t => t.trim().toLowerCase())
  }));

  console.log('âš™ï¸ Filtering open locations...');
  console.log('ðŸ“¦ All Locations:', allLocations);
  console.log('ðŸŽ¯ Theme Keywords:', themeKeywords);
  console.log('ðŸ• Current Day Parts:', currentDayParts);

  const openLocations = allLocations.filter(loc => {
    const allKeywords = [...loc.vibe, ...loc.tags];
    const matchesPrice = !priceFilter || (loc.price && priceTiers.indexOf(loc.price) <= selectedTierIndex);
    const matchesTheme = !theme || themeKeywords.some(kw => allKeywords.includes(kw));
    let matchesDayPart = false;
    let dayPartsArray = [];
    if (Array.isArray(loc.dayParts)) {
      dayPartsArray = loc.dayParts;
    } else if (typeof loc.dayParts === 'object' && loc.dayParts !== null) {
      dayPartsArray = Object.values(loc.dayParts).filter(p => p && p !== '-');
    }

    if (dayPartsArray.length > 0 && dayPartsArray.some(p => p !== '-')) {
      matchesDayPart = dayPartsArray.some(part => currentDayParts.includes(part));
    } else {
      const today = new Date().toLocaleDateString('en-US', { weekday: 'long' });
      const hoursTodayStr = Array.isArray(loc.hours)
        ? loc.hours.find(h => h.toLowerCase().startsWith(today.toLowerCase()))
        : null;

      if (hoursTodayStr && !hoursTodayStr.toLowerCase().includes('closed')) {
        const timeRangeMatch = hoursTodayStr.match(/\d{1,2}:\d{2}\s*[ap]m\s*[\u2013\-]\s*\d{1,2}:\d{2}\s*[ap]m/i);
        if (timeRangeMatch) {
          const [startStr, endStr] = timeRangeMatch[0].split(/[\u2013\-]/).map(s => s.trim());

          function parseTime(str) {
            const [time, meridian] = str.split(/\s+/);
            let [h, m] = time.split(':').map(Number);
            if (meridian.toLowerCase() === 'pm' && h !== 12) h += 12;
            if (meridian.toLowerCase() === 'am' && h === 12) h = 0;
            return h + m / 60;
          }

          const now = new Date();
          const currentTimeDecimal = now.getHours() + now.getMinutes() / 60;
          const startDecimal = parseTime(startStr);
          const endDecimal = parseTime(endStr);

          matchesDayPart = currentTimeDecimal >= startDecimal && currentTimeDecimal <= endDecimal;
        }
      }
    }

    const passes = matchesPrice && matchesTheme && matchesDayPart;

    if (!passes) {
      console.warn(`[FILTER OUT]`, {
        name: loc.name,
        matchesPrice,
        matchesTheme,
        matchesDayPart,
        currentDayParts,
        locDayParts: loc.dayParts,
        allKeywords
      });
    }

    return passes;
  });

  console.log('âœ… Matched Locations:', openLocations);
  if (!openLocations.length) {
    alert('No matching locations are open now for that theme.');
    return;
  }

  center = L.latLng(neighborhoodCenter.lat, neighborhoodCenter.lng);
  const validLocations = openLocations.filter(ev => ev.lat && ev.lon && !isNaN(ev.lat) && !isNaN(ev.lon));

  validLocations.forEach(ev => {
    const vibeMatches = ev.vibe.filter(v => themeKeywords.includes(v));
    const tagMatches = ev.tags.filter(t => themeKeywords.includes(t));
    const dist = center.distanceTo(L.latLng(ev.lat, ev.lon));
    ev._score = (vibeMatches.length + tagMatches.length) / (dist + 1);
    ev._score += ev.dateEvents?.some(e => e.date === todayStr) ? 1 : 0;
  });

  const sorted = validLocations.filter(ev => center.distanceTo(L.latLng(ev.lat, ev.lon)) <= 1500).sort((a, b) => b._score - a._score);

  const crawlStages = crawlFlows[theme] || [];
const crawlRoute = [];
let timeSpent = 0;
let lastPoint = center;

// D+1 timing state
let lastStopStartTime = new Date(crawlStart); // first stop begins at crawlStart
let lastStopDuration = 0;                     // populated after picking a stop

  let startingStageIndex = crawlStages.findIndex(stage => {
    return sorted.some(loc => loc.type === stage && themeKeywords.some(kw => [...loc.vibe, ...loc.tags].includes(kw)));
  });

  if (startingStageIndex === -1) {
    alert("No suitable starting point found for this theme.");
    return;
  }

  for (let i = startingStageIndex; i < crawlStages.length; i++) {
  const stage = crawlStages[i];

  const stageCandidates = sorted.filter(loc => {
    const vibeAndTags = [...(loc.vibe || []), ...(loc.tags || [])];
    const matchesType = loc.type === stage;
    const matchesVibe = themeKeywords.some(kw => vibeAndTags.includes(kw));
    const withinDistance = lastPoint.distanceTo(L.latLng(loc.lat, loc.lon)) <= 800;
    const fitsTime = timeSpent + (loc.duration || 1) <= maxDuration;

    // D+1 arrival time (no travel time per your requirement)
    // Rule: only enforce D+1 *after* the initial stop.
    // If crawlRoute.length === 0, we're selecting the very first stopâ€”skip D+1 check.
    let passesDPlusOne = true;
    if (crawlRoute.length > 0) {
      const arrivalD1 = new Date(
        lastStopStartTime.getTime()
        + (lastStopDuration || (crawlRoute[crawlRoute.length-1]?.duration || 1))*3600_000
        + (1 * 3600_000) // +1 hour buffer
      );
      passesDPlusOne = isOpenAt(loc, arrivalD1);
      // Optional: store debug data for summary logs
      loc._arrivalCheck = arrivalD1.toISOString();
      loc._arrivalPass = passesDPlusOne;
    }

    return matchesType && matchesVibe && withinDistance && fitsTime && passesDPlusOne;
  });

  if (!stageCandidates.length) continue;

  const next = stageCandidates[Math.floor(Math.random() * stageCandidates.length)];

console.log('[D+1 CHECK]', {
  candidate: next.name,
  arrivalAt: next._arrivalCheck || '(first stop)',
  passed: next._arrivalPass ?? true
});
    
  crawlRoute.push(next);

  // update timing state for next hop
  lastStopStartTime = (crawlRoute.length === 1) ? new Date(crawlStart) : new Date(
    lastStopStartTime.getTime()
    + (lastStopDuration || (crawlRoute[crawlRoute.length-2]?.duration || 1))*3600_000
    + (bufferHours * 3600_000) // D+1 buffer between previous and this stop
  );
  lastStopDuration = next.duration || 1;

  timeSpent += next.duration || 1;
  lastPoint = L.latLng(next.lat, next.lon);
  sorted.splice(sorted.indexOf(next), 1);
}


  if (crawlRoute.length < 2) {
    alert('Could not build a full crawl with available stops.');
    return;
  }

  if (window.routeLayer) map.removeControl(window.routeLayer);
  const waypoints = crawlRoute.map(loc => L.latLng(loc.lat, loc.lon));
  window.routeLayer = L.Routing.control({
    waypoints,
    routeWhileDragging: false,
    draggableWaypoints: false,
    addWaypoints: false,
    show: false
  }).addTo(map);

  selectedRoute = [...crawlRoute];
  showCrawlSummary(crawlRoute);
  filterMapToRoute();
  setClearRouteButtonEnabled(selectedRoute.length >= 2);

  // Hide other locations on the map
try {
  const routeIds = crawlRoute.map(l => l.id || l.name); // whatever your marker uses
  showOnlyRouteMarkers(map, window.allMarkers || [], routeIds);
} catch (e) {
  console.warn('Marker filtering failed:', e);
}
}

   // âœ… Only trigger crawl logic on button click â€” no arguments needed
document.getElementById('crawlNowBtn').addEventListener('click', generateCrawlRoute);

  // Simple modal HTML injection
function openFavoritesModal() {
  const savedFromStorage = localStorage.getItem('savedRoutes');
  const routes = savedFromStorage ? JSON.parse(savedFromStorage) : [];

  console.log('ðŸ“¦ Routes from localStorage:', routes);

  let html = `
    <div id="modal" style="position:fixed;top:10%;left:50%;transform:translateX(-50%);background:white;padding:20px;z-index:2000;border:1px solid #ccc;max-height:80%;overflow:auto;box-shadow:0 0 10px rgba(0,0,0,0.3);border-radius:8px;">
      <h2>Saved Routes</h2>
  `;

  if (!routes.length) {
    html += '<p>No routes saved.</p>';
  } else {
    routes.forEach((route, idx) => {
      html += `<div style="margin-bottom:10px;"><strong>Route #${idx + 1}</strong><ul>`;
      route.forEach(loc => {
        html += `<li>${loc.name}</li>`;
      });
      html += `</ul>
        <button data-idx="${idx}" class="load-route">Load</button>
        <button data-idx="${idx}" class="export-route">Export to Google Maps</button>
      </div>`;
    });
  }

  html += `
    <hr>
    <button id="closeModal">Close</button>
    </div>
  `;

  document.getElementById('modal')?.remove(); // ensure no duplicate modals
  document.body.insertAdjacentHTML('beforeend', html);

  document.getElementById('closeModal').onclick = () => {
    document.getElementById('modal').remove();
  };

  document.querySelectorAll('.load-route').forEach(btn => {
    btn.onclick = () => {
      selectedRoute = routes[btn.dataset.idx];
      drawRoute();
      document.getElementById('modal').remove();
    };
  });

  document.querySelectorAll('.export-route').forEach(btn => {
    btn.onclick = () => {
      const idx = btn.dataset.idx;
      const route = routes[idx];
      const base = "https://www.google.com/maps/dir/";
      const waypoints = route.map(loc => `${loc.lat},${loc.lng}`).join('/');
      const url = `${base}${waypoints}`;
      window.open(url, '_blank');
    };
  });
}

  
</script>
<div style="position: absolute; bottom: 3px; right: 0px; z-index: 1000; background: rgba(255,255,255,0.8); padding: 4px 8px; border-radius: 4px; font-size: 8px;">
  Â© 2025 Roam. All rights reserved. The Roam Appâ„¢ is a trademark of Roam Curated LLC.
</div>
</body>
</html>
