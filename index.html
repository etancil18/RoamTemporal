<!DOCTYPE html>
<html>
<head>
  <title>Roam Crawl Map</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    #map {
      height: 100vh;
      width: 100vw;
    }
    #details {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: white;
      padding: 10px;
      display: none;
      border-top: 1px solid #ccc;
    }
  </style>
</head>
<body>
<div class="controls">
  <input id="map-search" type="text" placeholder="What's the vibe..." />

  <select id="themeDropdown">
    <option value="">Select Theme</option>
    <option value="Quiet Luxury">Quiet Luxury</option>
    <option value="Hedonist's Loop">Hedonist's Loop</option>
    <option value="Creative Recharge">Creative Recharge</option>
    <option value="Wellness Ritual">Wellness Ritual</option>
    <option value="Alt Crawl">Alt Crawl</option>
    <option value="Power Lunch">Power Lunch</option>
    <option value="Cozy Corners">Cozy Corners</option>
    <option value="Flirt & Flow">Flirt & Flow</option>
    <option value="Urban Safari">Urban Safari</option>
  </select>

  <select id="neighborhood-input">
    <option value="">Select Neighborhood</option>
    <option>Alphabet City</option>
    <option>BedStuy</option>
    <option>Bushwick</option>
    <option>Chelsea</option>
    <option>Chinatown</option>
    <option>Clinton Hill</option>
    <option>Downtown Brooklyn</option>
    <option>Dumbo</option>
    <option>East Village</option>
    <option>Gramercy</option>
    <option>Greenpoint</option>
    <option>Greenwich Village</option>
    <option>Lower East Side</option>
    <option>Long Island City</option>
    <option>Midtown</option>
    <option>SoHo</option>
    <option>Tribeca</option>
    <option>Upper East Side</option>
    <option>Upper West Side</option>
    <option>West Village</option>
    <option>Williamsburg</option>
  </select>

  <select id="priceFilter">
    <option value="">Price</option>
    <option value="$">$</option>
    <option value="$$">$$</option>
    <option value="$$$">$$$</option>
    <option value="$$$$">$$$$</option>
  </select>

  <select id="durationDropdown">
    <option value="medium">How Long?</option>
    <option value="short">Short (≤2h)</option>
    <option value="medium">Medium (2.5–5h)</option>
    <option value="long">Long (5.5–8h)</option>
  </select>

  <button id="crawlNowBtn">Crawl Now</button>
  <button id="favoritesCrawlBtn">Favorites Crawl</button>
  <button id="removeLastPoint">Remove Last Point</button>
  <button id="clearRoute">Clear Route</button>
</div>
<div id="map"></div>
<div id="details"></div>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>
<script>

 const map = L.map('map').setView([40.72, -73.98], 12);
L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
  attribution: '&copy; OpenStreetMap contributors & Carto',
  subdomains: 'abcd',
  maxZoom: 19
}).addTo(map);

 function findMarkerByLatLng(latlng) {
  return allMarkers.find(m => {
    const mLatLng = m.getLatLng();
    return Math.abs(mLatLng.lat - latlng.lat) < 0.0001 &&
           Math.abs(mLatLng.lng - latlng.lng) < 0.0001;
  });
}
  
function parseSharedCrawl() {
  const params = new URLSearchParams(window.location.search);
  const crawlData = params.get('crawl');
  if (!crawlData) return;

  const coords = crawlData.split('|').map(p => {
    const [lat, lng] = p.split(',').map(Number);
    return {
      latlng: L.latLng(lat, lng)
    };
  });

  selectedPoints = coords.map(p => p.latlng);

  coords.forEach(p => {
    const marker = findMarkerByLatLng(p.latlng);
    if (marker) enlargeMarker(marker);
  });

  if (selectedPoints.length > 1) {
    updateRoute();
    map.fitBounds(L.featureGroup(
      selectedPoints.map(latlng => L.marker(latlng))
    ).getBounds());
  }

  const details = document.getElementById('details');
  const crawlPoints = coords.map(p => findMarkerByLatLng(p.latlng)).filter(Boolean);
  const shareLink = generateShareURL(selectedPoints);

  details.innerHTML = `<strong>Your Crawl:</strong><ul>${
    crawlPoints.map((m, i) => `<li>${i + 1}. <a href="${m.options.link || '#'}" target="_blank">${m.name}</a></li>`).join('')
  }</ul>
  <button id="exportGooglePopup">Export Route to Google Maps</button>
  <button id="copyLinkBtn">Copy Shareable Link</button>
  <input id="shareLinkInput" type="text" readonly value="${shareLink}" style="width:100%; margin-top:5px;" />
  <a id="smsShare" href="sms:?body=Check out this crawl: ${encodeURIComponent(shareLink)}" target="_blank">📲 Text This Crawl</a>
  <button id="closeDetails">Close</button>`;

  details.style.display = 'block';

  document.getElementById('exportGooglePopup').addEventListener('click', () => {
    const baseUrl = "https://www.google.com/maps/dir/";
    const path = selectedPoints.map(p => `${p.lat},${p.lng}`).join('/');
    window.open(baseUrl + path, '_blank');
  });

  document.getElementById('copyLinkBtn').addEventListener('click', () => {
    const input = document.getElementById('shareLinkInput');
    input.select();
    document.execCommand('copy');
    alert('Link copied to clipboard!');
  });

  document.getElementById('closeDetails').addEventListener('click', () => {
    details.style.display = 'none';
  });
  function showOnlySharedMarkers(latlngArray) {
  markerCluster.clearLayers();
  allMarkers.forEach(marker => {
    const mLatLng = marker.getLatLng();
    const match = latlngArray.some(p =>
      Math.abs(mLatLng.lat - p.lat) < 0.0001 &&
      Math.abs(mLatLng.lng - p.lng) < 0.0001
    );
    if (match) {
      markerCluster.addLayer(marker);
    }
  });
}
}



  
const markerCluster = L.markerClusterGroup({
  spiderfyOnMaxZoom: true,
  showCoverageOnHover: false,
  zoomToBoundsOnClick: true,
  maxClusterRadius: 40,
  disableClusteringAtZoom: 17
});
map.addLayer(markerCluster);

const allMarkers = [];
let selectedPoints = [];
let currentRoute = null;
let enlargedMarkers = new Set();

const defaultIcon = L.divIcon({
  className: 'custom-blue-icon',
  html: '', // You can add a number or letter here if desired
  iconSize: [18, 18],
  iconAnchor: [9, 18]
});

const enlargedIcon = L.icon({
  iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-violet.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});

const isSharedCrawl = new URLSearchParams(window.location.search).has('crawl');

const favorites = getFavorites();  
  
fetch('events.json')
  .then(res => res.json())
  .then(events => {
    events.forEach(ev => {
      const marker = L.marker([ev.lat, ev.lon], { icon: defaultIcon });
      marker.vibe = ev.vibe.toLowerCase();
      marker.name = ev.name.toLowerCase();
      marker.price = ev.price;
      marker.duration = ev.duration || 0;
      marker.options.link = ev.link;
      marker.options.hours = ev.hours || [];

      if (favorites.some(f => f.toLowerCase() === ev.name.toLowerCase())) {
  enlargeMarker(marker); 
}
      
      marker.on('click', () => {
        resetAllEnlargedMarkers();
        enlargeMarker(marker);
        showDetails(ev, marker.getLatLng());
      });

      allMarkers.push(marker);
    });
    
    if (isSharedCrawl) {
      parseSharedCrawl();

      // Filter: show only shared markers
      const sharedKeys = new Set(selectedPoints.map(p => `${p.lat.toFixed(5)},${p.lng.toFixed(5)}`));
      allMarkers.forEach(marker => {
        const { lat, lng } = marker.getLatLng();
        const key = `${lat.toFixed(5)},${lng.toFixed(5)}`;
        if (sharedKeys.has(key)) {
          markerCluster.addLayer(marker);
        }
      });
    } else {
      // Normal: show all markers
      allMarkers.forEach(marker => {
        markerCluster.addLayer(marker);
      });
    }
  });
  
function getTodayHours(hoursArray = []) {
  const today = new Date().toLocaleDateString('en-US', { weekday: 'long' });
  return hoursArray.find(entry => entry.startsWith(today)) || "Hours not available";
}

function isOpenNow(hoursArray = []) {
  const today = new Date().toLocaleDateString('en-US', { weekday: 'long' });
  const entry = hoursArray.find(h => h.toLowerCase().startsWith(today.toLowerCase()));
  if (!entry) return false;

  const [openStr, closeStr] = entry.replace(/[–—−]/g, "-").split("-").map(str => str.trim());
  if (!openStr || !closeStr) return false;

  const now = new Date();
  const openTime = new Date(`${now.toDateString()} ${openStr}`);
  let closeTime = new Date(`${now.toDateString()} ${closeStr}`);
  if (closeTime <= openTime) closeTime.setDate(closeTime.getDate() + 1);

  return now >= openTime && now <= closeTime;
}

  document.getElementById('map-search').addEventListener('input', applyFilters);

  document.getElementById('crawlNowBtn')?.addEventListener('click', () => {
        const neighborhood = document.getElementById('neighborhood-input')?.value;
        const theme = document.getElementById('themeDropdown')?.value;
        const price = document.getElementById('priceFilter')?.value;
        const duration = document.getElementById('durationDropdown')?.value;

        if (!neighborhood) {
          alert('Please select a neighborhood first.');
          return;
        }

        generateCrawl({ neighborhood, theme, price, duration });
      });
});

function applyFilters() {
  const query = document.getElementById('map-search').value.toLowerCase();
  markerCluster.clearLayers();
  allMarkers.forEach(marker => {
    const match = !query || marker.name.toLowerCase().includes(query) || marker.vibe.toLowerCase().includes(query);
    if (match) markerCluster.addLayer(marker.markerInstance);
  });
}

function showDetails(name) {
  const marker = allMarkers.find(m => m.name === name);
  if (!marker) return;

  const details = document.getElementById('details');
  const todayHours = marker.hours || "No hours available";
  const isOpen = marker.dayParts && /M|MD|A|HH|E|L/.test(marker.dayParts);
  const statusText = isOpen ? "🟢 Open Now" : "🔴 Closed Now";

  details.innerHTML = `
    <strong>${marker.name}</strong><br>
    Vibe: ${marker.vibe}<br>
    Price: ${marker.price || "N/A"}<br>
    Status: ${statusText}<br>
    Today's Hours: ${todayHours}<br>
    <a href="${marker.link}" target="_blank">View More</a><br>
    <button id="favoriteLocationBtn">❤️</button>
    <button id="addToRoute">Add to Route</button>
    <button id="exportGooglePopup">Export Route to Google Maps</button>
    <button id="closeDetails">Close</button>
  `;

  details.style.display = 'block';
  document.getElementById('favoriteLocationBtn').onclick = () => alert(`Favorited: ${marker.name}`);
  document.getElementById('addToRoute').onclick = () => {
    selectedPoints.push(marker.latlng);
    alert(`Added to route: ${marker.name}`);
  };
  document.getElementById('exportGooglePopup').onclick = () => {
    if (selectedPoints.length < 2) return alert('Select at least 2 points to export.');
    const base = "https://www.google.com/maps/dir/";
    const path = selectedPoints.map(p => `${p.lat},${p.lng}`).join('/');
    window.open(base + path, '_blank');
  };
  document.getElementById('closeDetails').onclick = () => {
    details.style.display = 'none';
  };
}

function generateCrawl({ neighborhood, theme, price, duration }) {
  const now = new Date();
  const hour = now.getHours();
  let dayPart = '';
  if (hour < 11) dayPart = 'M';
  else if (hour < 14) dayPart = 'MD';
  else if (hour < 17) dayPart = 'A';
  else if (hour < 19) dayPart = 'HH';
  else if (hour < 22) dayPart = 'E';
  else dayPart = 'L';

  const durationRange = {
    short: { min: 0, max: 2 },
    medium: { min: 2.5, max: 5 },
    long: { min: 5.5, max: 8 }
  }[duration];

  const themeVibes = {
    "Quiet Luxury": ["luxury", "elegant", "refined"],
    "Hedonist's Loop": ["party", "dance", "cocktail"],
    "Creative Recharge": ["coffee", "art", "gallery", "creative"],
    "Wellness Ritual": ["spa", "wellness", "juice"],
    "Alt Crawl": ["alt", "underground", "grunge"],
    "Power Lunch": ["business", "lunch", "network"],
    "Cozy Corners": ["cozy", "quiet", "nook"],
    "Flirt & Flow": ["romantic", "date", "vibe"],
    "Urban Safari": ["rooftop", "scenic", "explore"]
  }[theme] || [];

  const priceTiers = {
    "$": ["$"],
    "$$": ["$", "$$"],
    "$$$": ["$", "$$", "$$$"],
    "$$$$": ["$", "$$", "$$$", "$$$$"]
  };

  const priceOptions = priceTiers[price] || ["$", "$$", "$$$", "$$$$"];

  const used = new Set();
  const crawl = [];
  let currentTime = hour;
  let currentDayPart = dayPart;
  let currentDuration = 0;

  const getNextDayPart = (time) => {
    if (time < 11) return 'M';
    if (time < 14) return 'MD';
    if (time < 17) return 'A';
    if (time < 19) return 'HH';
    if (time < 22) return 'E';
    return 'L';
  };

  const center = neighborhoodCenters[neighborhood.toLowerCase()];

  let current = allMarkers.find(marker => {
    const inNeighborhood = marker.neighborhood && marker.neighborhood.toLowerCase() === neighborhood.toLowerCase();
    const matchesPrice = !marker.price || priceOptions.includes(marker.price.trim());
    const isOpenNow = marker.dayParts && marker.dayParts.includes(currentDayPart);
    const matchesTheme = marker.vibe && themeVibes.some(tv => marker.vibe.toLowerCase().includes(tv));
    const nearCenter = center && marker.latlng.distanceTo(center) <= 200;
    return inNeighborhood && matchesPrice && isOpenNow && matchesTheme && nearCenter;
  });

  if (!current) return alert('No suitable starting location found for this time and theme.');

  crawl.push(current);
  used.add(current.name);
  currentDuration += current.duration || 1;

  while (currentDuration < durationRange.max) {
    currentTime += Math.round(current.duration || 1);
    currentDayPart = getNextDayPart(currentTime);

    const maxDistances = [500, 275, 150];
    const fallbackDistance = 75;
    const stepIndex = crawl.length - 1;
    const maxDistance = stepIndex < maxDistances.length ? maxDistances[stepIndex] : fallbackDistance;

    const next = allMarkers.find(marker => {
      if (used.has(marker.name) || marker === current) return false;
      const isClose = current.latlng.distanceTo(marker.latlng) <= maxDistance;
      const sharesVibe = marker.vibe && current.vibe && marker.vibe.split(',').some(v => current.vibe.includes(v));
      const themeMatch = themeVibes.some(tv => marker.vibe && marker.vibe.toLowerCase().includes(tv));
      const isOpen = marker.dayParts && marker.dayParts.includes(currentDayPart);
      const matchesPrice = !marker.price || priceOptions.includes(marker.price.trim());
      return isClose && sharesVibe && themeMatch && isOpen && marker.duration && matchesPrice;
    });

    if (!next) break;

    crawl.push(next);
    used.add(next.name);
    currentDuration += next.duration;
    current = next;

    if (currentDuration >= durationRange.min) break;
  }

  if (crawl.length < 2) return alert('Unable to generate a full crawl.');

  displayCrawl(crawl);
}

function displayCrawl(route) {
  if (crawlLayer) {
    map.removeLayer(crawlLayer);
  }

  const markers = route.map(point => L.marker(point.latlng).bindPopup(`<strong>${point.name}</strong><br>${point.vibe}`));
  const latlngs = route.map(point => point.latlng);

  crawlLayer = L.layerGroup([
    ...markers,
    L.polyline(latlngs, { color: 'blue', weight: 4, opacity: 0.7 })
  ]);

  crawlLayer.addTo(map);
  map.fitBounds(L.featureGroup(markers).getBounds(), { padding: [20, 20] });
}


</script>
</body>
</html>
