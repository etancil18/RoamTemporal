<!DOCTYPE html>
<html>
<head>
  <title>Roam Temporal Map</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
    }
    #map {
      height: 100vh;
      width: 100vw;
    }
    .controls {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      z-index: 1000;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      background: rgba(255,255,255,0.9);
      padding: 8px;
      border-radius: 8px;
    }
    .controls select,
    .controls button {
      font-size: 14px;
      padding: 5px;
      flex: 1 1 120px;
    }
  </style>
</head>
<body>
<div class="controls">
  <input type="text" id="vibeSearchInput" placeholder="What's the vibe..." />
  <select id="themeDropdown">
  <option value="">Select Theme</option>
  <option value="Date Night">Date Night</option>
  <option value="Work Session">Work Session</option>
  <option value="Party Time">Party Time</option>
  <option value="Self-Care">Self-Care</option>
  <option value="Art & Culture">Art & Culture</option>
  <option value="Cheap & Cheerful">Cheap & Cheerful</option>
  <option value="Rooftops & Views">Rooftops & Views</option>
  <option value="Foodie Tour">Foodie Tour</option>
  <option value="Chill Hang">Chill Hang</option>
  <option value="Hidden Gems">Hidden Gems</option>
  <option value="Sunrise Start">Sunrise Start</option>
  <option value="Golden Hour">Golden Hour</option>
  <option value="Nightcap Circuit">Nightcap Circuit</option>
  <option value="Post-Work Wind Down">Post-Work Wind Down</option>
  <option value="Midday Recharge">Midday Recharge</option>
  <option value="Health Nut">Health Nut</option>
  <option value="Artsy & Indie">Artsy & Indie</option>
  <option value="Tech Bro Escape">Tech Bro Escape</option>
  <option value="Rom-Com Main Character">Rom-Com Main Character</option>
  <option value="Solo Explorer">Solo Explorer</option>
  <option value="Brunch & Beyond">Brunch & Beyond</option>
  <option value="Saturday Surge">Saturday Surge</option>
  <option value="Sunday Reset">Sunday Reset</option>
  <option value="Weekend Warriors">Weekend Warriors</option>
  <option value="Late Start Legends">Late Start Legends</option>
  </select>
  <select id="neighborhood-input">
  <option value="">Select Neighborhood</option>
  <option value="alphabet city">Alphabet City</option>
  <option value="bedstuy">BedStuy</option>
  <option value="bushwick">Bushwick</option>
  <option value="chelsea">Chelsea</option>
  <option value="chinatown">Chinatown</option>
  <option value="clinton hill">Clinton Hill</option>
  <option value="downtown brooklyn">Downtown Brooklyn</option>
  <option value="dumbo">Dumbo</option>
  <option value="east village">East Village</option>
  <option value="gramercy">Gramercy</option>
  <option value="greenpoint">Greenpoint</option>
  <option value="greenwich village">Greenwich Village</option>
  <option value="lower east side">Lower East Side</option>
  <option value="long island city">Long Island City</option>
  <option value="midtown">Midtown</option>
  <option value="soho">SoHo</option>
  <option value="tribeca">Tribeca</option>
  <option value="upper east side">Upper East Side</option>
  <option value="upper west side">Upper West Side</option>
  <option value="west village">West Village</option>
  <option value="williamsburg">Williamsburg</option>
</select>
  <select id="priceFilter">
    <option value="">Price</option>
    <option value="$">$</option>
    <option value="$$">$$</option>
    <option value="$$$">$$$</option>
    <option value="$$$$">$$$$</option>
  </select>
  <select id="durationDropdown">
    <option value="medium">How Long?</option>
    <option value="short">Short (≤2h)</option>
    <option value="medium">Medium (2.5–5h)</option>
    <option value="long">Long (5.5–8h)</option>
  </select>
  <button id="crawlNowBtn">Crawl Now</button>
</div>
<div id="map"></div>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>
<script>
const defaultIcon = L.icon({
  iconUrl: 'https://unpkg.com/leaflet@1.9.3/dist/images/marker-icon.png',
  shadowUrl: 'https://unpkg.com/leaflet@1.9.3/dist/images/marker-shadow.png',
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});

  let allLocations = [];
  
const map = L.map('map').setView([40.72, -73.98], 12);
L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
  attribution: '&copy; OpenStreetMap contributors & Carto',
  subdomains: 'abcd',
  maxZoom: 19
}).addTo(map);

  const dayPartColors = {
  M: 'blue',         // Morning
  MD: 'green',       // Midday
  A: 'orange',       // Afternoon
  HH: 'gold',      // Happy Hour 
  E: 'violet',          // Evening
  L: 'red'         // Late Night 
};

  function isLocationOpenNow(ev) {
  const now = new Date();
  const dayKeys = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
  const todayKey = dayKeys[now.getDay()];
  const currentHour = now.getHours();

  const hours = ev.hoursNumeric?.[todayKey];
  if (!hours || hours.open === undefined || hours.close === undefined) return false;

  // Handle closing after midnight
  if (hours.close < hours.open) {
    return currentHour >= hours.open || currentHour < hours.close;
  }
  return currentHour >= hours.open && currentHour < hours.close;
}
  
  const markerLayer = L.layerGroup().addTo(map);

function renderMarkers(events) {
  markerLayer.clearLayers();
  allMarkers = []; // Reset global marker store

  const weekdayKeys = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
  const todayIndex = new Date().getDay();
  const todayKey = weekdayKeys[todayIndex];

  // Create markers and cache
  events.forEach(ev => {
    const rawPart = ev.dayParts?.[todayKey];
    const isOpen = isLocationOpenNow(ev);

    const markerColor =
      isOpen && rawPart && rawPart !== '-'
        ? (dayPartColors[rawPart] || 'grey')
        : 'grey';

    const icon = new L.Icon({
      iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-${markerColor}.png`,
      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });

    const marker = L.marker([parseFloat(ev.lat), parseFloat(ev.lon)], { icon });
    marker.ev = ev;
    allMarkers.push(marker);
  });

  // Attach popups with Nearby Similar logic
  allMarkers.forEach(marker => {
    const ev = marker.ev;
    const latlng = marker.getLatLng();
    const isOpen = isLocationOpenNow(ev);

    const thisVibes = (ev.vibe || '')
      .split(',')
      .map(v => v.trim().toLowerCase())
      .filter(Boolean);

    const similar = allMarkers
      .filter(m => m !== marker && latlng.distanceTo(m.getLatLng()) <= 350)
      .filter(m => {
        const otherVibes = (m.ev.vibe || '')
          .split(',')
          .map(v => v.trim().toLowerCase())
          .filter(Boolean);
        return thisVibes.some(v => otherVibes.includes(v));
      })
      .slice(0, 3);

    const similarList = similar.length
      ? '<ul>' + similar.map(m => `<li>${m.ev.name}</li>`).join('') + '</ul>'
      : '<em>No similar places nearby.</em>';

    const popupContent = `
      <div style="font-size: 14px; line-height: 1.4;">
        <strong>${ev.name}</strong><br/>
        <em>Vibe:</em> ${ev.vibe}<br/>
        <em>Hours:</em> ${ev.hours?.[todayIndex] || 'N/A'}<br/>
        <em>Status:</em> ${isOpen ? '<span style="color:green;">Open Now</span>' : '<span style="color:red;">Closed</span>'}<br/>
        <a href="${ev.link}" target="_blank">More Info</a>
        <hr/>
        <strong>Could also be the move..:</strong>
        ${similarList}
      </div>
    `;

    marker.bindPopup(popupContent).addTo(markerLayer);
  });
}

  function filterMarkersByVibe() {
  const vibeSearch = document.getElementById('vibeSearchInput').value.trim().toLowerCase();

  const filteredEvents = globalEvents.filter(ev => {
    if (!vibeSearch) return true;
    if (typeof ev.vibe === 'string') {
      return ev.vibe.toLowerCase().includes(vibeSearch);
    }
    if (Array.isArray(ev.vibe)) {
      return ev.vibe.some(v => v.toLowerCase().includes(vibeSearch));
    }
    return false;
  });

  renderMarkers(filteredEvents);
}
  
// Global cache for crawl logic
let globalEvents = [];

// Initial data fetch + map rendering
fetch('events.json')
  .then(res => res.json())
  .then(events => {
    globalEvents = events;         // Store globally
    renderMarkers(events);         // Render all locations immediately
    document.getElementById('vibeSearchInput').addEventListener('input', filterMarkersByVibe);
  })
  .catch(err => {
    console.error('Error loading events:', err);
    alert('Failed to load locations.');
  });

const neighborhoodCenters = {
  "alphabet city": L.latLng(40.7265, -73.9815),
  "bedstuy": L.latLng(40.6850, -73.9419),
  "bushwick": L.latLng(40.6943, -73.9213),
  "chelsea": L.latLng(40.7465, -74.0014),
  "chinatown": L.latLng(40.7158, -73.9970),
  "clinton hill": L.latLng(40.6896, -73.9606),
  "downtown brooklyn": L.latLng(40.6928, -73.9903),
  "dumbo": L.latLng(40.7033, -73.9881),
  "east village": L.latLng(40.7260, -73.9816),
  "gramercy": L.latLng(40.7376, -73.9857),
  "greenpoint": L.latLng(40.7301, -73.9546),
  "greenwich village": L.latLng(40.7336, -74.0027),
  "lower east side": L.latLng(40.7150, -73.9843),
  "long island city": L.latLng(40.7440, -73.9488),
  "midtown": L.latLng(40.7549, -73.9840),
  "soho": L.latLng(40.7233, -74.0030),
  "tribeca": L.latLng(40.7163, -74.0086),
  "upper east side": L.latLng(40.7736, -73.9566),
  "upper west side": L.latLng(40.7870, -73.9754),
  "west village": L.latLng(40.7359, -74.0036),
  "williamsburg": L.latLng(40.7081, -73.9571)
};

  const themeMap = {
  "date night": ["romantic", "cocktail", "jazz", "twilight", "vibe", "wine", "dim", "moody"],
  "work session": ["cafe", "wifi", "coffee", "focus", "quiet", "workspace", "daytime"],
  "party time": ["club", "dance", "beats", "late", "dj", "loud", "drinks", "bar"],
  "self-care": ["spa", "relax", "yoga", "meditation", "serenity", "retreat", "tea"],
  "art & culture": ["gallery", "museum", "art", "exhibit", "creative", "theater", "film"],
  "cheap & cheerful": ["diner", "cheap", "budget", "street", "casual", "$", "bite", "fast"],
  "rooftops & views": ["rooftop", "view", "skyline", "sunset", "elevated", "balcony", "overlook"],
  "foodie tour": ["restaurant", "tasting", "chef", "bistro", "eats", "gastro", "brunch"],
  "chill hang": ["lounge", "cozy", "relaxed", "intimate", "chill", "sofa", "vintage"],
  "hidden gems": ["speakeasy", "secret", "underground", "niche", "alt", "unmarked", "local"],
  "Sunrise Start": [
    "coffee", "matcha", "sunrise", "morning", "café", "bakery", "brunch", "acai", "patio", "quiet"
  ],
  "Golden Hour": [
    "rooftop", "patio", "sunset", "cocktail", "wine", "view", "outdoor", "aperitif", "photogenic"
  ],
  "Nightcap Circuit": [
    "speakeasy", "whiskey", "jazz", "cozy", "lounge", "low light", "late", "neat", "intimate"
  ],
  "Post-Work Wind Down": [
    "happy hour", "bar", "tapas", "light bite", "craft beer", "after work", "relax", "casual"
  ],
  "Midday Recharge": [
    "lunch", "café", "juice", "quick bite", "park", "sunlight", "relaxed", "low key", "grab-and-go"
  ],
  "Health Nut": [
    "wellness", "juice", "smoothie", "matcha", "organic", "spa", "bathhouse", "vegan", "yoga", "light bite"
  ],
  "Artsy & Indie": [
    "gallery", "vinyl", "underground", "zine", "eclectic", "alt", "poetry", "studio", "indie", "niche"
  ],
  "Tech Bro Escape": [
    "steakhouse", "cocktail", "crypto", "rooftop", "sleek", "bourbon", "high-end", "modern", "rare", "network"
  ],
  "Rom-Com Main Character": [
    "twilight", "charming", "patio", "vintage", "wine", "candlelit", "walkable", "cozy", "date", "serendipity"
  ],
  "Solo Explorer": [
    "bookstore", "quiet", "scenic", "café", "park", "rooftop", "garden", "introspective", "nook", "wander"
  ],
  "Brunch & Beyond": [
    "brunch", "mimosa", "day party", "pancakes", "bistro", "patio", "sunny", "casual", "daytime"
  ],
  "Saturday Surge": [
    "dance", "dj", "crowded", "club", "party", "high energy", "beats", "rooftop", "late", "scene"
  ],
  "Sunday Reset": [
    "garden", "tea", "spa", "quiet", "book", "relax", "wellness", "reflection", "meditation", "sunlight"
  ],
  "Weekend Warriors": [
    "dive bar", "after hours", "shots", "karaoke", "late night", "chaotic", "party", "crowd", "open late"
  ],
  "Late Start Legends": [
    "brunch", "cocktails", "twilight", "pre-game", "vibe", "evening", "casual", "low key", "date"
  ]
};

function matchesTheme(loc, theme) {
  const keywords = themeMap[theme] || [];
  const allTags = [
    ...(loc.vibe || []),
    ...(typeof loc.tags === 'string' ? loc.tags.split(',').map(t => t.trim().toLowerCase()) : [])
  ];
  return keywords.some(kw => allTags.includes(kw));
}

function getCurrentDayPart() {
  const hour = new Date().getHours();
  if (hour >= 6 && hour < 11) return ['M'];
  if (hour >= 11 && hour < 14) return ['MD'];
  if (hour >= 14 && hour < 16) return ['A'];
  if (hour >= 16 && hour < 19) return ['HH'];
  if (hour >= 19 && hour < 22) return ['E'];
  return ['L']; // Late night or overnight
}
  
function generateCrawlRoute() {
  if (!globalEvents.length) {
    alert("Locations not loaded yet. Please wait a second and try again.");
    return;
  }

  const neighborhood = document.getElementById('neighborhood-input').value.toLowerCase();
  const priceFilter = document.getElementById('priceFilter').value.trim();
  const theme = document.getElementById('themeDropdown').value.toLowerCase();
  const durationSetting = document.getElementById('durationDropdown').value;
  const neighborhoodCenter = neighborhoodCenters[neighborhood];

  if (!neighborhoodCenter) {
    alert('Invalid neighborhood selected.');
    return;
  }

  const allLocations = globalEvents.map(ev => ({
    name: ev.name,
    vibe: typeof ev.vibe === 'string' ? ev.vibe.split(',').map(v => v.trim().toLowerCase()) : [],
    lat: parseFloat(ev.lat),
    lon: parseFloat(ev.lon),
    link: ev.link,
    openNow: ev.openNow,
    hours: ev.hours || [],
    hoursNumeric: ev.hoursNumeric || {},
    dayParts: Object.values(ev.dayParts || {}).filter(dp => dp !== '-' && dp !== ''),
    timeCategory: ev.timeCategory,
    energyRamp: ev.energyRamp,
    tags: ev.tags,
    price: ev.price,
    duration: ev.duration
  }));

      const currentDayParts = getCurrentDayPart();
      const priceTiers = ['$', '$$', '$$$', '$$$$'];
      const selectedTierIndex = priceTiers.indexOf(priceFilter);

      const openLocations = allLocations.filter(loc => {
  const matchesPrice = !priceFilter || (loc.price && priceTiers.indexOf(loc.price) <= selectedTierIndex);

  const themeKeywords = themeMap[theme] || [];
  const matchesTheme = !theme || themeKeywords.some(kw => {
    const vibeMatch = loc.vibe?.some(v => v.includes(kw));
    const tagMatch = typeof loc.tags === 'string' && loc.tags.toLowerCase().includes(kw);
    return vibeMatch || tagMatch;
  });

  const currentIndex = ['M', 'MD', 'A', 'HH', 'E', 'L'].findIndex(p => currentDayParts.includes(p));
  const futureParts = ['M', 'MD', 'A', 'HH', 'E', 'L'].slice(currentIndex);
  const currentPart = currentDayParts[0];
  const isCurrentlyOpen = loc.dayParts.includes(currentPart);
  const isOpenLater = loc.dayParts.some(part => futureParts.includes(part));


  return matchesPrice && matchesTheme && (isCurrentlyOpen || isOpenLater);
});

      runCrawlPlanner(openLocations, neighborhoodCenter, durationSetting);
    };

  // ✅ Only trigger crawl logic on button click — no arguments needed
document.getElementById('crawlNowBtn').addEventListener('click', generateCrawlRoute);

function runCrawlPlanner(openLocations, neighborhoodCenter, durationSetting) {
  function checkOpenLocations(openLocations) {
    if (openLocations.length === 0) {
      alert('No suitable locations found.');
      return false;
    }
    return true;
  }

  function checkInitialOptions(initialOptions) {
    if (initialOptions.length === 0) {
      alert('No suitable starting points within the neighborhood center.');
      return false;
    }
    return true;
  }

  function checkCrawlRoute(crawlRoute) {
    if (crawlRoute.length < 2) {
      alert('A crawl requires at least 2 stops. Try adjusting your filters or duration.');
      return false;
    }
    return true;
  }

  if (!checkOpenLocations(openLocations)) return;

  const initialOptions = openLocations.filter(loc => {
  const center = L.latLng(neighborhoodCenter.lat, neighborhoodCenter.lon);
  const locLatLng = L.latLng(loc.lat, loc.lon);
  const withinRadius = center.distanceTo(locLatLng) <= 1500;

  const themeKeywords = themeMap[theme] || [];
  const allVibes = Array.isArray(loc.vibe) ? loc.vibe : [];
  const sharedVibes = allVibes.filter(v => themeKeywords.includes(v));
  const vibeMatch = sharedVibes.length >= 2;

  const currentPart = getCurrentDayPart()[0];
  const isOpenNow = loc.dayParts.includes(currentPart);

  return withinRadius && vibeMatch && isOpenNow;
});

if (!checkInitialOptions(initialOptions)) return;

// 🔀 Randomly pick the first stop
const firstStop = initialOptions[Math.floor(Math.random() * initialOptions.length)];
const crawlRoute = [firstStop];
let totalDuration = firstStop.duration || 0;
const maxDuration = durationSetting === 'short' ? 2 : durationSetting === 'medium' ? 5 : 8;

let lastStop = firstStop;
let lastDayPartIndex = ['M', 'MD', 'A', 'HH', 'E', 'L'].findIndex(p => lastStop.dayParts.includes(p));
const remaining = openLocations.filter(loc => loc !== lastStop);

for (let loc of remaining) {
  if (theme && !matchesTheme(loc, theme)) continue;
  if (!loc.duration || totalDuration + loc.duration > maxDuration) continue;

  const lastLatLng = L.latLng(lastStop.lat, lastStop.lon);
  const locLatLng = L.latLng(loc.lat, loc.lon);
  if (lastLatLng.distanceTo(locLatLng) <= 350) {
    const locDayPartIndex = ['M', 'MD', 'A', 'HH', 'E', 'L'].findIndex(p => loc.dayParts.includes(p));
    if (locDayPartIndex >= lastDayPartIndex) {
      crawlRoute.push(loc);
      totalDuration += loc.duration;
      lastStop = loc;
      lastDayPartIndex = locDayPartIndex;
    }
  }

  if (totalDuration >= maxDuration) break;
}

  if (!checkCrawlRoute(crawlRoute)) return;

  if (window.routeLayer) {
    map.removeControl(window.routeLayer);
  }

  const waypoints = crawlRoute.map(loc => L.latLng(loc.lat, loc.lon));
  window.routeLayer = L.Routing.control({
    waypoints,
    routeWhileDragging: false,
    draggableWaypoints: false,
    addWaypoints: false,
    show: false
  }).addTo(map);
}


</script>
<div style="position: absolute; bottom: 3px; right: 0px; z-index: 1000; background: rgba(255,255,255,0.8); padding: 4px 8px; border-radius: 4px; font-size: 8px;">
  © 2025 Roam. All rights reserved. The Roam App™ is a trademark of Roam Curated LLC.
</div>
</body>
</html>
