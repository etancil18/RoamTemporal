<!DOCTYPE html>
<html>
<head>
  <title>Roam Temporal Map</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
    }
    #map {
      height: 100vh;
      width: 100vw;
    }
    .controls {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      z-index: 1000;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      background: rgba(255,255,255,0.9);
      padding: 8px;
      border-radius: 8px;
    }
    .controls select,
    .controls button {
      font-size: 14px;
      padding: 5px;
      flex: 1 1 120px;
    }
  </style>
</head>
<body>
<div class="controls">
  <select id="themeDropdown">
    <option value="">Select Theme</option>
    <option value="Quiet Luxury">Quiet Luxury</option>
    <option value="Hedonist's Loop">Hedonist's Loop</option>
    <option value="Creative Recharge">Creative Recharge</option>
    <option value="Wellness Ritual">Wellness Ritual</option>
    <option value="Alt Crawl">Alt Crawl</option>
    <option value="Power Lunch">Power Lunch</option>
    <option value="Cozy Corners">Cozy Corners</option>
    <option value="Flirt & Flow">Flirt & Flow</option>
    <option value="Urban Safari">Urban Safari</option>
  </select>
  <select id="neighborhood-input">
    <option value="">Select Neighborhood</option>
    <option>Alphabet City</option>
    <option>BedStuy</option>
    <option>Bushwick</option>
    <option>Chelsea</option>
    <option>Chinatown</option>
    <option>Clinton Hill</option>
    <option>Downtown Brooklyn</option>
    <option>Dumbo</option>
    <option>East Village</option>
    <option>Gramercy</option>
    <option>Greenpoint</option>
    <option>Greenwich Village</option>
    <option>Lower East Side</option>
    <option>Long Island City</option>
    <option>Midtown</option>
    <option>SoHo</option>
    <option>Tribeca</option>
    <option>Upper East Side</option>
    <option>Upper West Side</option>
    <option>West Village</option>
    <option>Williamsburg</option>
  </select>
  <select id="priceFilter">
    <option value="">Price</option>
    <option value="$">$</option>
    <option value="$$">$$</option>
    <option value="$$$">$$$</option>
    <option value="$$$$">$$$$</option>
  </select>
  <select id="durationDropdown">
    <option value="medium">How Long?</option>
    <option value="short">Short (≤2h)</option>
    <option value="medium">Medium (2.5–5h)</option>
    <option value="long">Long (5.5–8h)</option>
  </select>
  <button id="crawlNowBtn">Crawl Now</button>
</div>
<div id="map"></div>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>
<script>
const defaultIcon = L.icon({
  iconUrl: 'https://unpkg.com/leaflet@1.9.3/dist/images/marker-icon.png',
  shadowUrl: 'https://unpkg.com/leaflet@1.9.3/dist/images/marker-shadow.png',
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});

  let allLocations = [];
  
const map = L.map('map').setView([40.72, -73.98], 12);
L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
  attribution: '&copy; OpenStreetMap contributors & Carto',
  subdomains: 'abcd',
  maxZoom: 19
}).addTo(map);

  const dayPartColors = {
  M: 'blue',        // Morning
  MD: 'green',      // Midday
  A: 'orange',      // Afternoon
  HH: 'purple',     // Happy Hour
  E: 'red',         // Evening
  L: 'black'        // Late Night
};

  function renderMarkers(events) {
  const weekdayKeys = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
  const todayIndex = new Date().getDay();
  const todayKey = weekdayKeys[todayIndex];

  events.forEach(ev => {
    const relevantDayPart = ev.dayParts?.[todayKey] && ev.dayParts[todayKey] !== '-'
      ? ev.dayParts[todayKey]
      : 'M';
    const markerColor = dayPartColors[relevantDayPart] || 'gray';

    const icon = new L.Icon({
      iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-${markerColor}.png`,
      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });

    const marker = L.marker([parseFloat(ev.lat), parseFloat(ev.lon)], { icon });
    const popupContent = `
      <div style="font-size: 14px; line-height: 1.4;">
        <strong>${ev.name}</strong><br/>
        <em>Vibe:</em> ${ev.vibe}<br/>
        <em>Hours:</em> ${ev.hours?.[todayIndex] || 'N/A'}<br/>
        <a href="${ev.link}" target="_blank">More Info</a>
      </div>
    `;
    marker.bindPopup(popupContent).addTo(map);
  });
}

// Global cache for crawl logic
let globalEvents = [];

// Initial data fetch + map rendering
fetch('events.json')
  .then(res => res.json())
  .then(events => {
    globalEvents = events;         // Store globally
    renderMarkers(events);         // Render all locations immediately
  })
  .catch(err => {
    console.error('Error loading events:', err);
    alert('Failed to load locations.');
  });

function generateCrawlRoute() {
  if (!globalEvents.length) {
    alert("Locations not loaded yet. Please wait a second and try again.");
    return;
  }

  const neighborhood = document.getElementById('neighborhood-input').value.toLowerCase();
  const priceFilter = document.getElementById('priceFilter').value.trim();
  const theme = document.getElementById('themeDropdown').value.toLowerCase();
  const durationSetting = document.getElementById('durationDropdown').value;
  const neighborhoodCenter = neighborhoodCenters[neighborhood];

  if (!neighborhoodCenter) {
    alert('Invalid neighborhood selected.');
    return;
  }

  const allLocations = globalEvents.map(ev => ({
    name: ev.name,
    vibe: typeof ev.vibe === 'string' ? ev.vibe.split(',').map(v => v.trim().toLowerCase()) : [],
    lat: parseFloat(ev.lat),
    lon: parseFloat(ev.lon),
    link: ev.link,
    openNow: ev.openNow,
    hours: ev.hours || [],
    hoursNumeric: ev.hoursNumeric || {},
    dayParts: Object.values(ev.dayParts || {}).filter(dp => dp !== '-' && dp !== ''),
    timeCategory: ev.timeCategory,
    energyRamp: ev.energyRamp,
    tags: ev.tags,
    price: ev.price,
    duration: ev.duration
  }));

      const currentDayParts = getCurrentDayPart();
      const priceTiers = ['$', '$$', '$$$', '$$$$'];
      const selectedTierIndex = priceTiers.indexOf(priceFilter);

      const openLocations = allLocations.filter(loc => {
        const matchesPrice = !priceFilter || (loc.price && priceTiers.indexOf(loc.price) <= selectedTierIndex);
        const matchesTheme = !theme || (themeMap[theme] || []).some(kw => loc.vibe?.join(' ').includes(kw));
        const currentIndex = ['M', 'MD', 'A', 'HH', 'E', 'L'].findIndex(p => currentDayParts.includes(p));
        const futureParts = ['M', 'MD', 'A', 'HH', 'E', 'L'].slice(currentIndex);
        const isOpenTemporal = loc.dayParts.some(part => futureParts.includes(part));
        return matchesPrice && matchesTheme && isOpenTemporal;
      });

      runCrawlPlanner(openLocations, neighborhoodCenter, durationSetting);
    });
}

function runCrawlPlanner(openLocations, neighborhoodCenter, durationSetting) {
  function checkOpenLocations(openLocations) {
    if (openLocations.length === 0) {
      alert('No suitable locations found.');
      return false;
    }
    return true;
  }

  function checkInitialOptions(initialOptions) {
    if (initialOptions.length === 0) {
      alert('No suitable starting points within the neighborhood center.');
      return false;
    }
    return true;
  }

  function checkCrawlRoute(crawlRoute) {
    if (crawlRoute.length < 2) {
      alert('A crawl requires at least 2 stops. Try adjusting your filters or duration.');
      return false;
    }
    return true;
  }

  if (!checkOpenLocations(openLocations)) return;

  const initialOptions = openLocations.filter(loc => {
    const center = L.latLng(neighborhoodCenter.lat, neighborhoodCenter.lon);
    const locLatLng = L.latLng(loc.lat, loc.lon);
    return center.distanceTo(locLatLng) <= 175;
  });

  if (!checkInitialOptions(initialOptions)) return;

  const crawlRoute = [initialOptions[0]];
  let totalDuration = initialOptions[0].duration || 0;
  const maxDuration = durationSetting === 'short' ? 2 : durationSetting === 'medium' ? 5 : 8;

  let lastStop = initialOptions[0];
  let lastDayPartIndex = ['M', 'MD', 'A', 'HH', 'E', 'L'].findIndex(p => lastStop.dayParts.includes(p));
  const remaining = openLocations.filter(loc => loc !== lastStop);

  for (let loc of remaining) {
    if (!loc.duration || totalDuration + loc.duration > maxDuration) continue;
    const lastLatLng = L.latLng(lastStop.lat, lastStop.lon);
    const locLatLng = L.latLng(loc.lat, loc.lon);
    if (lastLatLng.distanceTo(locLatLng) <= 350) {
      const locDayPartIndex = ['M', 'MD', 'A', 'HH', 'E', 'L'].findIndex(p => loc.dayParts.includes(p));
      if (locDayPartIndex >= lastDayPartIndex) {
        crawlRoute.push(loc);
        totalDuration += loc.duration;
        lastStop = loc;
        lastDayPartIndex = locDayPartIndex;
      }
    }
    if (totalDuration >= maxDuration) break;
  }

  if (!checkCrawlRoute(crawlRoute)) return;

  if (window.routeLayer) {
    map.removeControl(window.routeLayer);
  }

  const waypoints = crawlRoute.map(loc => L.latLng(loc.lat, loc.lon));
  window.routeLayer = L.Routing.control({
    waypoints,
    routeWhileDragging: false,
    draggableWaypoints: false,
    addWaypoints: false,
    show: false
  }).addTo(map);
}

// ✅ Only trigger crawl logic on button click — no arguments needed
document.getElementById('crawlNowBtn').addEventListener('click', generateCrawlRoute);


</script>
<div style="position: absolute; bottom: 3px; right: 0px; z-index: 1000; background: rgba(255,255,255,0.8); padding: 4px 8px; border-radius: 4px; font-size: 8px;">
  © 2025 Roam. All rights reserved. The Roam App™ is a trademark of Roam Curated LLC.
</div>
</body>
</html>
